/* -*- c++ -*- */
/*
 * Copyright 2012 Free Software Foundation, Inc.
 * Copyright 2012 Dimitri Stolnikov <horiz0n@gmx.net>
 *
 * This file is part of GNU Radio
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <rtl_source_c.h>
#include <gr_io_signature.h>

#include <stdexcept>
#include <iostream>
#include <stdio.h>

#include <rtl-sdr.h>

/*
 * Create a new instance of rtl_source_c and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
rtl_source_c_sptr
make_rtl_source_c (const std::string &args)
{
  return gnuradio::get_initial_sptr(new rtl_source_c (args));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 0;	// mininum number of input streams
static const int MAX_IN = 0;	// maximum number of input streams
static const int MIN_OUT = 1;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

/*
 * The private constructor
 */
rtl_source_c::rtl_source_c (const std::string &args)
  : gr_sync_block ("rtl_source_c",
        gr_make_io_signature (MIN_IN, MAX_IN, sizeof (gr_complex)),
        gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof (gr_complex)))
{
  int ret;
  int dev_index = 0;

  _buf = boost::circular_buffer<unsigned char>(1024*1024);

  // create a lookup table for gr_complex values
  for (unsigned int i = 0; i <= 0xffff; i++)
  {
    _lut.push_back( gr_complex( (float(i >> 8) - 127.0) * 0.00787,
                                (float(i & 0xff) - 127.0) * 0.00787 ) );
  }

  std::cout << "Opening " << rtlsdr_get_device_name(dev_index) << std::endl;

  _dev = NULL;
  ret = rtlsdr_open(&_dev, dev_index);
  if (ret < 0)
      throw std::runtime_error("failed to open rtlsdr device.");

  ret = rtlsdr_reset_buffer(_dev);
  if (ret < 0)
      throw std::runtime_error("failed to reset usb buffers.");

  rtlsdr_set_sample_rate( _dev, 2048000 );

  _has_i_sample = false;

  _thread = gruel::thread(_rtlsdr_wait, this);
}

/*
 * Our virtual destructor.
 */
rtl_source_c::~rtl_source_c ()
{
  if (_dev) {
    rtlsdr_cancel_async( _dev );
    _thread.join();
    rtlsdr_close( _dev );
    _dev = NULL;
  }
}

void rtl_source_c::_rtlsdr_callback(unsigned char *buf, uint32_t len, void *ctx)
{
  rtl_source_c *obj = (rtl_source_c *)ctx;
  obj->rtlsdr_callback(buf, len);
}

void rtl_source_c::rtlsdr_callback(unsigned char *buf, uint32_t len)
{
    boost::mutex::scoped_lock lock( _buf_mutex );

    for (int i = 0; i < len; i++) {
      if (!_buf.full()) {
        _buf.push_back(buf[i]);
        _buf_cond.notify_one();
      } else {
        printf("O"); fflush(stdout);
        break;
      }
    }
}

void rtl_source_c::_rtlsdr_wait(rtl_source_c *obj)
{
  obj->rtlsdr_wait();
}

void rtl_source_c::rtlsdr_wait()
{
  int ret = rtlsdr_wait_async(_dev, _rtlsdr_callback, (void *)this);
  if (-10 == ret)
    ret = rtlsdr_wait_async(_dev, _rtlsdr_callback, (void *)this);

  std::cout << "rtlsdr_wait() finished due to " << ret << std::endl;
}

int rtl_source_c::work( int noutput_items,
                        gr_vector_const_void_star &input_items,
                        gr_vector_void_star &output_items )
{
  gr_complex *out = (gr_complex *) output_items[0];

  unsigned short index = 0;

  int items_left = noutput_items;
  while ( items_left )
  {
    {
      boost::mutex::scoped_lock lock( _buf_mutex );

      while( _buf.empty() ) {
          _buf_cond.wait( lock );
      }
    }

    if (!_has_i_sample) {
      index = _buf.front() << 8;
      _buf.pop_front();
      _has_i_sample = true;
    } else {
      index |= _buf.front();
      _buf.pop_front();
      _has_i_sample = false;
    }

    if (_has_i_sample)
      continue;

    // convert samples to gr_complex type by using the lookup table
    *out++ = _lut[index];

    items_left--;
  }

  return noutput_items;
}

double rtl_source_c::set_center_freq(double freq)
{
  if (_dev) {
    rtlsdr_set_center_freq( _dev, (unsigned int)freq );
    return (double)rtlsdr_get_center_freq( _dev );
  }

  return 0;
}

double rtl_source_c::set_sample_rate( double rate )
{
  if (_dev) {
    rtlsdr_set_sample_rate( _dev, (unsigned int)rate );
    return (double)rtlsdr_get_sample_rate( _dev );
  }

  return 0;
}

double rtl_source_c::get_sample_rate()
{
  if (_dev)
    return (double) rtlsdr_get_sample_rate( _dev );

  return 0;
}

double rtl_source_c::set_gain( double gain )
{
  if (_dev) {
    rtlsdr_set_tuner_gain( _dev, (unsigned int)gain );
    return (double)rtlsdr_get_tuner_gain( _dev );
  }

  return 0;
}
